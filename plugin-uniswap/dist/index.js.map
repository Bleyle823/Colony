{"version":3,"sources":["../src/actions/quote.ts","../src/services/uniswapService.ts","../src/services/tokens.ts","../src/actions/swap.ts","../src/actions/enhancedSwap.ts","../src/services/enhancedUniswapService.ts","../src/index.ts"],"sourcesContent":["import { Action, ActionResult, IAgentRuntime, Memory, State, HandlerCallback, elizaLogger } from \"@elizaos/core\";\r\nimport { UniswapService } from \"../services/uniswapService\";\r\nimport { getTokenBySymbol } from \"../services/tokens\";\r\n\r\nexport const getQuoteAction: Action = {\r\n    name: \"GET_QUOTE\",\r\n    similes: [\"QUOTE_PRICE\", \"CHECK_PRICE\", \"PRICE_CHECK\"],\r\n    description: \"Get a quote for swapping tokens on Uniswap V4\",\r\n    validate: async (runtime: IAgentRuntime, message: Memory) => {\r\n        return !!runtime.getSetting(\"EVM_PRIVATE_KEY\") || !!runtime.getSetting(\"WALLET_PRIVATE_KEY\");\r\n    },\r\n    handler: async (\r\n        runtime: IAgentRuntime,\r\n        message: Memory,\r\n        state: State | undefined,\r\n        options: { [key: string]: any },\r\n        callback?: HandlerCallback\r\n    ) => {\r\n        elizaLogger.info(\"Handling GET_QUOTE action\");\r\n\r\n        const content = message.content.text || \"\";\r\n        const amountMatch = content.match(/(\\d+(\\.\\d+)?)/);\r\n        const amount = amountMatch ? amountMatch[0] : \"1\";\r\n\r\n        const words = content.split(\" \");\r\n        const symbols = words\r\n            .map(w => w.trim().replace(/[.,]/g, ''))\r\n            .filter(w => getTokenBySymbol(w));\r\n\r\n        const tokenIn = symbols[0] || \"ETH\";\r\n        const tokenOut = symbols[1] || \"USDC\";\r\n\r\n        try {\r\n            const service = new UniswapService(runtime);\r\n            await service.initialize(runtime);\r\n\r\n            const quote = await service.getQuote(tokenIn, tokenOut, amount);\r\n\r\n            if (callback) {\r\n                callback({\r\n                    text: `Quote: ${amount} ${tokenIn} ‚âà ${quote} ${tokenOut} on Uniswap V4.`,\r\n                });\r\n            }\r\n            return { success: true, text: `Quote: ${amount} ${tokenIn} ‚âà ${quote} ${tokenOut}`, data: { amount, tokenIn, tokenOut, quote } };\r\n        } catch (error: any) {\r\n            elizaLogger.error(\"Error in GET_QUOTE handler:\", error);\r\n            if (callback) {\r\n                callback({\r\n                    text: `Failed to get quote: ${error.message}`,\r\n                });\r\n            }\r\n            return { success: false, error: error?.message ?? \"Unknown error\" };\r\n        }\r\n    },\r\n    examples: [\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: { text: \"Get quote for 1 ETH to USDC\" },\r\n            },\r\n            {\r\n                user: \"{{agentName}}\",\r\n                content: {\r\n                    text: \"Quote: 1 ETH ‚âà 2500 USDC on Uniswap V4.\",\r\n                    action: \"GET_QUOTE\",\r\n                },\r\n            },\r\n        ],\r\n    ],\r\n};\r\n","import { Service, IAgentRuntime, logger } from \"@elizaos/core\";\r\nimport { ethers } from \"ethers\";\r\nimport { SwapExactInSingle, PoolKey, SwapExactIn } from '@uniswap/v4-sdk';\r\nimport { Token, CurrencyAmount, TradeType, Percent } from '@uniswap/sdk-core';\r\nimport { getTokenBySymbol, ETH_TOKEN, USDC_TOKEN } from \"./tokens\";\r\n\r\n// CONSTANTS (Replace with actual deployment addresses for the target chain)\r\nconst QUOTER_ADDRESS = \"0x0000000000000000000000000000000000000000\"; // TODO: Update\r\nconst UNIVERSAL_ROUTER_ADDRESS = \"0x66a9893cC07D91D95644AEDD05D03f95e1dBA8Af\"; // TODO: Update\r\nconst PERMIT2_ADDRESS = \"0x000000000022D473030F116dDEE9F6B43aC78BA3\"; // TODO: Update\r\n\r\n// Minimal ABI for Quoter\r\nconst QUOTE_ABI = [\r\n    \"function quoteExactInputSingle(tuple(address currency0, address currency1, uint24 fee, int24 tickSpacing, address hooks) poolKey, bool zeroForOne, uint128 exactAmount, bytes hookData) external returns (uint256 amountOut, uint128 sqrtPriceX96After, uint32 initializedTicksCrossed, uint256 gasEstimate)\",\r\n    \"function quoteExactInput(bytes path, uint128 amountIn) external returns (uint256 amountOut, uint128[] sqrtPriceX96AfterList, uint32[] initializedTicksCrossedList, uint256 gasEstimate)\"\r\n];\r\n\r\nexport class UniswapService extends Service {\r\n    static serviceType = \"uniswap\";\r\n    capabilityDescription = \"Uniswap V4 Swapping Service\";\r\n    private provider: ethers.JsonRpcProvider | null = null;\r\n    private wallet: ethers.Wallet | null = null;\r\n\r\n    async stop(): Promise<void> {\r\n        this.provider = null;\r\n        this.wallet = null;\r\n    }\r\n\r\n    async initialize(runtime: IAgentRuntime): Promise<void> {\r\n        const rpcUrl =\r\n            runtime.getSetting(\"ETHEREUM_PROVIDER_URL\") ||\r\n            runtime.getSetting(\"EVM_PROVIDER_URL\") ||\r\n            runtime.getSetting(\"UNISWAP_RPC_URL\") ||\r\n            runtime.getSetting(\"BASE_RPC_URL\");\r\n\r\n        if (!rpcUrl) throw new Error(\"UNISWAP_RPC_URL, BASE_RPC_URL, or EVM_PROVIDER_URL is not configured\");\r\n\r\n        this.provider = new ethers.JsonRpcProvider(rpcUrl);\r\n\r\n        const privateKey = runtime.getSetting(\"EVM_PRIVATE_KEY\") || runtime.getSetting(\"WALLET_PRIVATE_KEY\");\r\n        if (privateKey) {\r\n            this.wallet = new ethers.Wallet(privateKey, this.provider);\r\n        }\r\n\r\n        const network = await this.provider.getNetwork();\r\n        logger.info(`Uniswap Service initialized on chain ID: ${network.chainId}`);\r\n    }\r\n\r\n    /**\r\n     * Get a quote for swapping tokenIn to tokenOut\r\n     */\r\n    async getQuote(tokenInSymbol: string, tokenOutSymbol: string, amountIn: string): Promise<string> {\r\n        if (!this.provider) throw new Error(\"Provider not initialized\");\r\n\r\n        const tokenIn = getTokenBySymbol(tokenInSymbol);\r\n        const tokenOut = getTokenBySymbol(tokenOutSymbol);\r\n\r\n        if (!tokenIn || !tokenOut) {\r\n            throw new Error(`Token configuration not found for ${tokenInSymbol} or ${tokenOutSymbol}`);\r\n        }\r\n\r\n        const quoter = new ethers.Contract(QUOTER_ADDRESS, QUOTE_ABI, this.provider);\r\n\r\n        // Construct PoolKey (Simplified assuming direct pool exists with standard fee)\r\n        // In reality, we might need to find the best pool or route.\r\n        const poolKey = {\r\n            currency0: tokenIn.address < tokenOut.address ? tokenIn.address : tokenOut.address,\r\n            currency1: tokenIn.address < tokenOut.address ? tokenOut.address : tokenIn.address,\r\n            fee: 3000, // Default 0.3%\r\n            tickSpacing: 60,\r\n            hooks: ethers.ZeroAddress\r\n        };\r\n\r\n        const zeroForOne = tokenIn.address === poolKey.currency0;\r\n        const amountInParsed = ethers.parseUnits(amountIn, tokenIn.decimals);\r\n\r\n        try {\r\n            // Using callStatic to simulate\r\n            const result = await quoter.quoteExactInputSingle.staticCall(\r\n                poolKey,\r\n                zeroForOne,\r\n                amountInParsed,\r\n                \"0x\" // No hook data\r\n            );\r\n\r\n            const amountOut = ethers.formatUnits(result.amountOut, tokenOut.decimals);\r\n            return amountOut;\r\n        } catch (error: any) {\r\n            logger.error(\"Error fetching quote:\", error);\r\n            throw new Error(`Failed to fetch quote: ${error.message}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Execute a swap using SwapRouter02 (Uniswap V3)\r\n     */\r\n    async executeSwap(tokenInSymbol: string, tokenOutSymbol: string, amountIn: string): Promise<string> {\r\n        if (!this.wallet) throw new Error(\"Wallet not initialized with private key\");\r\n\r\n        const tokenIn = getTokenBySymbol(tokenInSymbol);\r\n        const tokenOut = getTokenBySymbol(tokenOutSymbol);\r\n\r\n        if (!tokenIn || !tokenOut) {\r\n            throw new Error(`Token configuration not found for ${tokenInSymbol} or ${tokenOutSymbol}`);\r\n        }\r\n\r\n        const SWAP_ROUTER_02_ADDRESS = \"0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45\";\r\n        const amountInWei = ethers.parseUnits(amountIn, tokenIn.decimals);\r\n\r\n        // 1. Check Balance and Allowance\r\n        if (tokenInSymbol !== 'ETH' && tokenInSymbol !== 'WETH') { // Treat WETH as ERC20\r\n            const tokenContract = new ethers.Contract(tokenIn.address, [\r\n                \"function balanceOf(address) view returns (uint256)\",\r\n                \"function allowance(address, address) view returns (uint256)\",\r\n                \"function approve(address, uint256) returns (bool)\"\r\n            ], this.wallet);\r\n\r\n            // Verify contract exists\r\n            const code = await this.provider!.getCode(tokenIn.address);\r\n            if (code === '0x') {\r\n                throw new Error(`Token contract ${tokenInSymbol} not found at ${tokenIn.address} on this chain. Check your configuration.`);\r\n            }\r\n\r\n            const balance = await tokenContract.balanceOf(this.wallet.address);\r\n            if (balance < amountInWei) {\r\n                throw new Error(`Insufficient balance of ${tokenInSymbol}. Have ${ethers.formatUnits(balance, tokenIn.decimals)}, need ${amountIn}`);\r\n            }\r\n\r\n            const allowance = await tokenContract.allowance(this.wallet.address, SWAP_ROUTER_02_ADDRESS);\r\n            if (allowance < amountInWei) {\r\n                logger.info(`Approving ${tokenInSymbol} for Uniswap Router...`);\r\n                const tx = await tokenContract.approve(SWAP_ROUTER_02_ADDRESS, ethers.MaxUint256);\r\n                logger.info(`Approval tx sent: ${tx.hash}`);\r\n                await tx.wait();\r\n                logger.info(\"Approval confirmed\");\r\n            }\r\n        } else if (tokenInSymbol === 'ETH') {\r\n            const balance = await this.provider!.getBalance(this.wallet.address);\r\n            if (balance < amountInWei) {\r\n                throw new Error(`Insufficient ETH balance. Have ${ethers.formatEther(balance)}, need ${amountIn}`);\r\n            }\r\n        }\r\n\r\n        // 2. Execute Swap\r\n        logger.info(`Executing swap: ${amountIn} ${tokenInSymbol} -> ${tokenOutSymbol}`);\r\n\r\n        const router = new ethers.Contract(SWAP_ROUTER_02_ADDRESS, [\r\n            \"function exactInputSingle((address tokenIn, address tokenOut, uint24 fee, address recipient, uint256 amountIn, uint256 amountOutMinimum, uint160 sqrtPriceLimitX96)) external payable returns (uint256 amountOut)\"\r\n        ], this.wallet);\r\n\r\n        const params = {\r\n            tokenIn: tokenIn.address,\r\n            tokenOut: tokenOut.address,\r\n            fee: 3000, // 0.3% pool fee\r\n            recipient: this.wallet.address,\r\n            amountIn: amountInWei,\r\n            amountOutMinimum: 0, // No slippage protection for demo simplicity\r\n            sqrtPriceLimitX96: 0\r\n        };\r\n\r\n        const overrides = tokenInSymbol === 'ETH' ? { value: amountInWei } : {};\r\n\r\n        try {\r\n            const tx = await router.exactInputSingle(params, overrides);\r\n            logger.info(`Swap transaction sent: ${tx.hash}`);\r\n\r\n            // Wait for confirmation\r\n            const receipt = await tx.wait();\r\n            logger.info(`Swap confirmed in block ${receipt.blockNumber}`);\r\n\r\n            return tx.hash;\r\n        } catch (error: any) {\r\n            logger.error(\"Swap failed executing transaction:\", error);\r\n            throw new Error(`Swap transaction failed: ${error.reason || error.message}`);\r\n        }\r\n    }\r\n}\r\n","import { Token, ChainId } from '@uniswap/sdk-core';\r\n\r\n// Define Chain ID (Ethereum Mainnet)\r\nexport const CHAIN_ID = ChainId.MAINNET;\r\n\r\nexport interface TokenConfig {\r\n    [symbol: string]: Token;\r\n}\r\n\r\n// Common Tokens\r\nexport const ETH_TOKEN = new Token(\r\n    CHAIN_ID,\r\n    '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2', // WETH on Mainnet\r\n    18,\r\n    'WETH',\r\n    'Wrapped Ether'\r\n);\r\n\r\nexport const USDC_TOKEN = new Token(\r\n    CHAIN_ID,\r\n    '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48', // USDC on Mainnet\r\n    6,\r\n    'USDC',\r\n    'USD Coin'\r\n);\r\n\r\n// RWA / xStocks Tokens\r\nexport const RWA_TOKENS: TokenConfig = {\r\n    'MF-ONE': new Token(\r\n        CHAIN_ID,\r\n        '0x238a700eD6165261Cf8b2e544ba797BC11e466Ba',\r\n        18,\r\n        'mF-ONE',\r\n        'mF-ONE Token'\r\n    ),\r\n    'AA_FalconXUSDC': new Token(\r\n        CHAIN_ID,\r\n        '0xC26A6Fa2C37b38E549a4a1807543801Db684f99C',\r\n        18,\r\n        'AA_FalconXUSDC',\r\n        'AA_FalconXUSDC'\r\n    ),\r\n    'APPLON': new Token(\r\n        CHAIN_ID,\r\n        '0x14c3abf95cb9c93a8b82c1cdcb76d72cb87b2d4c',\r\n        18,\r\n        'APPLON',\r\n        'Apple (Ondo Tokenized Stock)'\r\n    ),\r\n    'AAPLON': new Token(\r\n        CHAIN_ID,\r\n        '0x14c3abf95cb9c93a8b82c1cdcb76d72cb87b2d4c',\r\n        18,\r\n        'AAPLON',\r\n        'Apple (Ondo Tokenized Stock)'\r\n    ),\r\n    'APPLE': new Token(\r\n        CHAIN_ID,\r\n        '0x14c3abf95cb9c93a8b82c1cdcb76d72cb87b2d4c',\r\n        18,\r\n        'APPLE',\r\n        'Apple (Ondo Tokenized Stock)'\r\n    ),\r\n    'xAAPL': new Token(\r\n        CHAIN_ID,\r\n        '0x0000000000000000000000000000000000000002', // Placeholder\r\n        18,\r\n        'xAAPL',\r\n        'Wrapped Apple'\r\n    ),\r\n    'xTSLA': new Token(\r\n        CHAIN_ID,\r\n        '0x0000000000000000000000000000000000000003', // Placeholder\r\n        18,\r\n        'xTSLA',\r\n        'Wrapped Tesla'\r\n    )\r\n};    // Add more xStocks here\r\n\r\n\r\nexport const TOKENS: TokenConfig = {\r\n    'ETH': ETH_TOKEN,\r\n    'WETH': ETH_TOKEN,\r\n    'USDC': USDC_TOKEN,\r\n    ...RWA_TOKENS\r\n};\r\n\r\nexport const getTokenBySymbol = (symbol: string): Token | undefined => {\r\n    const normalizedSymbol = symbol.toUpperCase();\r\n    return TOKENS[normalizedSymbol];\r\n};\r\n","import { Action, ActionResult, IAgentRuntime, Memory, State, HandlerCallback, elizaLogger } from \"@elizaos/core\";\r\nimport { UniswapService } from \"../services/uniswapService\";\r\nimport { getTokenBySymbol } from \"../services/tokens\";\r\n\r\nexport const swapTokensAction: Action = {\r\n    name: \"EVM_SWAP_TOKENS\",\r\n    similes: [\"SWAP_TOKENS\", \"SWAP\", \"TRADE\", \"EXCHANGE\"],\r\n    description: \"Execute a token swap on Uniswap V4\",\r\n    validate: async (runtime: IAgentRuntime, message: Memory) => {\r\n        return !!runtime.getSetting(\"EVM_PRIVATE_KEY\") || !!runtime.getSetting(\"WALLET_PRIVATE_KEY\");\r\n    },\r\n    handler: async (\r\n        runtime: IAgentRuntime,\r\n        message: Memory,\r\n        state: State | undefined,\r\n        options: { [key: string]: any },\r\n        callback?: HandlerCallback\r\n    ) => {\r\n        elizaLogger.info(\"Handling SWAP_TOKENS action\");\r\n\r\n        const content = message.content.text || \"\";\r\n        const amountMatch = content.match(/(\\d+(\\.\\d+)?)/);\r\n        const amount = amountMatch ? amountMatch[0] : \"0\";\r\n\r\n        // Remove the amount from the text to avoid confusing it with a token\r\n        const textWithoutAmount = content.replace(amount, \"\");\r\n\r\n        const words = textWithoutAmount.split(\" \");\r\n        const symbols = words\r\n            .map(w => w.trim().replace(/[.,]/g, ''))\r\n            .filter(w => getTokenBySymbol(w));\r\n\r\n        // Smart fallback logic\r\n        let tokenIn = symbols[0];\r\n        let tokenOut = symbols[1];\r\n\r\n        if (!tokenIn) tokenIn = \"ETH\";\r\n        if (!tokenOut) tokenOut = \"USDC\";\r\n\r\n        const amountNum = parseFloat(amount);\r\n        if (!amountMatch || isNaN(amountNum) || amountNum <= 0) {\r\n            if (callback) {\r\n                callback({\r\n                    text: \"Please specify a valid positive amount to swap (e.g. Swap 0.1 ETH to USDC).\",\r\n                });\r\n            }\r\n            return { success: false, error: \"Invalid or missing swap amount\" };\r\n        }\r\n\r\n        try {\r\n            const service = new UniswapService(runtime);\r\n            await service.initialize(runtime);\r\n\r\n            const txHash = await service.executeSwap(tokenIn, tokenOut, amount);\r\n\r\n            if (callback) {\r\n                callback({\r\n                    text: `Swap executed! Transaction Hash: ${txHash}`,\r\n                });\r\n            }\r\n            return { success: true, text: `Swap executed. Tx: ${txHash}`, data: { txHash, tokenIn, tokenOut, amount } };\r\n        } catch (error: any) {\r\n            elizaLogger.error(\"Error in SWAP_TOKENS handler:\", error);\r\n            if (callback) {\r\n                callback({\r\n                    text: `Failed to execute swap: ${error.message}`,\r\n                });\r\n            }\r\n            return { success: false, error: error?.message ?? \"Unknown error\" };\r\n        }\r\n    },\r\n    examples: [\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: { text: \"Swap 0.1 ETH to USDC\" },\r\n            },\r\n            {\r\n                user: \"{{agentName}}\",\r\n                content: {\r\n                    text: \"Swap executed! Transaction Hash: 0x...\",\r\n                    action: \"EVM_SWAP_TOKENS\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: { text: \"Swap 1 USDC for MF-ONE\" },\r\n            },\r\n            {\r\n                user: \"{{agentName}}\",\r\n                content: {\r\n                    text: \"Swap executed! Transaction Hash: 0x...\",\r\n                    action: \"EVM_SWAP_TOKENS\",\r\n                },\r\n            },\r\n        ],\r\n    ],\r\n};\r\n","import { Action, ActionResult, IAgentRuntime, Memory, State, HandlerCallback, elizaLogger } from \"@elizaos/core\";\nimport { EnhancedUniswapService } from \"../services/enhancedUniswapService\";\nimport { getTokenBySymbol } from \"../services/tokens\";\n\nexport const enhancedSwapTokensAction: Action = {\n    name: \"ENHANCED_EVM_SWAP_TOKENS\",\n    similes: [\"SWAP_TOKENS\", \"SWAP\", \"TRADE\", \"EXCHANGE\", \"UNISWAP_SWAP\"],\n    description: \"Execute a token swap on Uniswap with enhanced reliability and error handling\",\n    validate: async (runtime: IAgentRuntime, message: Memory) => {\n        return !!runtime.getSetting(\"EVM_PRIVATE_KEY\") || !!runtime.getSetting(\"WALLET_PRIVATE_KEY\");\n    },\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State | undefined,\n        options: { [key: string]: any },\n        callback?: HandlerCallback\n    ) => {\n        elizaLogger.info(\"Handling ENHANCED_EVM_SWAP_TOKENS action\");\n\n        const content = message.content.text || \"\";\n        \n        // Enhanced parsing to handle various input formats\n        const parseSwapRequest = (text: string) => {\n            // Remove common words and normalize\n            const normalized = text.toLowerCase()\n                .replace(/\\b(swap|trade|exchange|convert|sell|buy)\\b/g, '')\n                .replace(/\\b(to|for|into|‚Üí|->)\\b/g, ' TO ')\n                .trim();\n            \n            // Extract amount - look for decimal numbers\n            const amountMatch = normalized.match(/(\\d+(?:\\.\\d+)?)/);\n            const amount = amountMatch ? amountMatch[1] : \"0\";\n            \n            // Remove amount from text for token parsing\n            const textWithoutAmount = normalized.replace(amount, '').trim();\n            \n            // Split by 'TO' to get input and output tokens\n            const parts = textWithoutAmount.split(' to ');\n            \n            let tokenIn = '';\n            let tokenOut = '';\n            \n            if (parts.length >= 2) {\n                // Format: \"X ETH TO USDC\"\n                const beforeTo = parts[0].trim().split(/\\s+/);\n                const afterTo = parts[1].trim().split(/\\s+/);\n                \n                tokenIn = beforeTo[beforeTo.length - 1]; // Last word before TO\n                tokenOut = afterTo[0]; // First word after TO\n            } else {\n                // Fallback: look for known tokens in the text\n                const words = textWithoutAmount.split(/\\s+/).filter(w => w.length > 0);\n                const tokens = words.filter(w => getTokenBySymbol(w.toUpperCase()));\n                \n                if (tokens.length >= 2) {\n                    tokenIn = tokens[0];\n                    tokenOut = tokens[1];\n                } else if (tokens.length === 1) {\n                    // Assume swapping to USDC if only one token mentioned\n                    tokenIn = tokens[0];\n                    tokenOut = 'USDC';\n                }\n            }\n            \n            return {\n                amount: parseFloat(amount),\n                tokenIn: tokenIn.toUpperCase(),\n                tokenOut: tokenOut.toUpperCase()\n            };\n        };\n\n        const swapRequest = parseSwapRequest(content);\n        \n        elizaLogger.info(`Parsed swap request:`, swapRequest);\n\n        // Validation\n        if (!swapRequest.amount || isNaN(swapRequest.amount) || swapRequest.amount <= 0) {\n            const errorMsg = \"Please specify a valid positive amount to swap (e.g., 'Swap 0.1 ETH to USDC' or 'Trade 100 USDC for ETH')\";\n            if (callback) {\n                callback({ text: errorMsg });\n            }\n            return { success: false, error: \"Invalid or missing swap amount\" };\n        }\n\n        // Default tokens if not specified\n        if (!swapRequest.tokenIn) swapRequest.tokenIn = \"ETH\";\n        if (!swapRequest.tokenOut) swapRequest.tokenOut = \"USDC\";\n\n        // Verify tokens exist\n        const tokenInConfig = getTokenBySymbol(swapRequest.tokenIn);\n        const tokenOutConfig = getTokenBySymbol(swapRequest.tokenOut);\n\n        if (!tokenInConfig) {\n            const errorMsg = `Token ${swapRequest.tokenIn} is not supported. Available tokens: ETH, USDC, WETH, DAI, USDT, APPLON, AAPLON, APPLE`;\n            if (callback) {\n                callback({ text: errorMsg });\n            }\n            return { success: false, error: `Unsupported input token: ${swapRequest.tokenIn}` };\n        }\n\n        if (!tokenOutConfig) {\n            const errorMsg = `Token ${swapRequest.tokenOut} is not supported. Available tokens: ETH, USDC, WETH, DAI, USDT, APPLON, AAPLON, APPLE`;\n            if (callback) {\n                callback({ text: errorMsg });\n            }\n            return { success: false, error: `Unsupported output token: ${swapRequest.tokenOut}` };\n        }\n\n        try {\n            elizaLogger.info(`Initializing Enhanced Uniswap Service...`);\n            const service = new EnhancedUniswapService();\n            await service.initialize(runtime);\n\n            elizaLogger.info(`Executing swap: ${swapRequest.amount} ${swapRequest.tokenIn} -> ${swapRequest.tokenOut}`);\n            \n            // Provide user feedback\n            if (callback) {\n                callback({\n                    text: `üîÑ Executing swap: ${swapRequest.amount} ${swapRequest.tokenIn} ‚Üí ${swapRequest.tokenOut}\\n\\nThis may take a moment while we find the best route and execute the transaction...`\n                });\n            }\n\n            const txHash = await service.executeSwap(\n                swapRequest.tokenIn, \n                swapRequest.tokenOut, \n                swapRequest.amount.toString()\n            );\n\n            const successMsg = `‚úÖ Swap executed successfully!\\n\\n` +\n                             `üìä ${swapRequest.amount} ${swapRequest.tokenIn} ‚Üí ${swapRequest.tokenOut}\\n` +\n                             `üîó Transaction: ${txHash}\\n` +\n                             `üåê View on Etherscan: https://etherscan.io/tx/${txHash}`;\n\n            if (callback) {\n                callback({\n                    text: successMsg\n                });\n            }\n\n            return { \n                success: true, \n                text: `Swap executed successfully. Tx: ${txHash}`, \n                data: { \n                    txHash, \n                    tokenIn: swapRequest.tokenIn, \n                    tokenOut: swapRequest.tokenOut, \n                    amount: swapRequest.amount,\n                    explorerUrl: `https://etherscan.io/tx/${txHash}`\n                } \n            };\n\n        } catch (error: any) {\n            elizaLogger.error(\"Error in ENHANCED_EVM_SWAP_TOKENS handler:\", error);\n            \n            // Enhanced error messages\n            let errorMessage = \"Failed to execute swap\";\n            \n            if (error.message.includes('insufficient funds') || error.message.includes('Insufficient')) {\n                errorMessage = `‚ùå Insufficient ${swapRequest.tokenIn} balance for this swap. Please check your wallet balance.`;\n            } else if (error.message.includes('no response') || error.message.includes('timeout')) {\n                errorMessage = `‚ùå Network connectivity issue. The RPC provider is not responding. Please try again in a moment.`;\n            } else if (error.message.includes('slippage') || error.message.includes('price')) {\n                errorMessage = `‚ùå Swap failed due to price movement. Try again with a smaller amount or higher slippage tolerance.`;\n            } else if (error.message.includes('allowance') || error.message.includes('approve')) {\n                errorMessage = `‚ùå Token approval failed. Please ensure you have enough ETH for gas fees and try again.`;\n            } else if (error.message.includes('No working RPC')) {\n                errorMessage = `‚ùå All RPC endpoints are currently unavailable. Please check your internet connection and try again later.`;\n            } else if (error.message.includes('not found') || error.message.includes('contract')) {\n                errorMessage = `‚ùå Token contract not found. Please verify the token symbols are correct.`;\n            } else {\n                errorMessage = `‚ùå Swap failed: ${error.message}`;\n            }\n            \n            if (callback) {\n                callback({\n                    text: errorMessage\n                });\n            }\n            \n            return { success: false, error: error?.message ?? \"Unknown error\" };\n        }\n    },\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: { text: \"Swap 0.1 ETH to USDC\" },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"üîÑ Executing swap: 0.1 ETH ‚Üí USDC\\n\\nThis may take a moment while we find the best route and execute the transaction...\",\n                    action: \"ENHANCED_EVM_SWAP_TOKENS\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: { text: \"Trade 100 USDC for ETH\" },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"üîÑ Executing swap: 100 USDC ‚Üí ETH\\n\\nThis may take a moment while we find the best route and execute the transaction...\",\n                    action: \"ENHANCED_EVM_SWAP_TOKENS\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: { text: \"Exchange 0.5 ETH to DAI\" },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"üîÑ Executing swap: 0.5 ETH ‚Üí DAI\\n\\nThis may take a moment while we find the best route and execute the transaction...\",\n                    action: \"ENHANCED_EVM_SWAP_TOKENS\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: { text: \"Swap 500 USDC to APPLON\" },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"üîÑ Executing swap: 500 USDC ‚Üí APPLON (Apple stock)\\n\\nThis may take a moment while we find the best route and execute the transaction...\",\n                    action: \"ENHANCED_EVM_SWAP_TOKENS\",\n                },\n            },\n        ],\n    ],\n};","import { Service, IAgentRuntime, logger } from \"@elizaos/core\";\nimport { ethers } from \"ethers\";\nimport { SwapExactInSingle, PoolKey, SwapExactIn } from '@uniswap/v4-sdk';\nimport { Token, CurrencyAmount, TradeType, Percent } from '@uniswap/sdk-core';\nimport { getTokenBySymbol, ETH_TOKEN, USDC_TOKEN } from \"./tokens\";\n\n// CONSTANTS (Replace with actual deployment addresses for the target chain)\nconst QUOTER_ADDRESS = \"0x0000000000000000000000000000000000000000\"; // TODO: Update\nconst UNIVERSAL_ROUTER_ADDRESS = \"0x66a9893cC07D91D95644AEDD05D03f95e1dBA8Af\"; // TODO: Update\nconst PERMIT2_ADDRESS = \"0x000000000022D473030F116dDEE9F6B43aC78BA3\"; // TODO: Update\n\n// Minimal ABI for Quoter\nconst QUOTE_ABI = [\n    \"function quoteExactInputSingle(tuple(address currency0, address currency1, uint24 fee, int24 tickSpacing, address hooks) poolKey, bool zeroForOne, uint128 exactAmount, bytes hookData) external returns (uint256 amountOut, uint128 sqrtPriceX96After, uint32 initializedTicksCrossed, uint256 gasEstimate)\",\n    \"function quoteExactInput(bytes path, uint128 amountIn) external returns (uint256 amountOut, uint128[] sqrtPriceX96AfterList, uint32[] initializedTicksCrossedList, uint256 gasEstimate)\"\n];\n\ninterface RPCEndpoint {\n    name: string;\n    url: string;\n    priority: number; // Lower number = higher priority\n}\n\nexport class EnhancedUniswapService extends Service {\n    static serviceType = \"enhanced-uniswap\";\n    capabilityDescription = \"Enhanced Uniswap V4 Swapping Service with Robust RPC Handling\";\n    private providers: Map<string, ethers.JsonRpcProvider> = new Map();\n    private wallet: ethers.Wallet | null = null;\n    private rpcEndpoints: RPCEndpoint[] = [];\n    private currentProvider: ethers.JsonRpcProvider | null = null;\n\n    async stop(): Promise<void> {\n        this.providers.clear();\n        this.wallet = null;\n        this.currentProvider = null;\n        this.rpcEndpoints = [];\n    }\n\n    async initialize(runtime: IAgentRuntime): Promise<void> {\n        // Configure RPC endpoints with fallbacks\n        this.setupRPCEndpoints(runtime);\n        \n        // Initialize providers\n        await this.initializeProviders();\n        \n        // Setup wallet\n        await this.setupWallet(runtime);\n        \n        logger.info(`Enhanced Uniswap Service initialized with ${this.providers.size} RPC providers`);\n    }\n\n    private setupRPCEndpoints(runtime: IAgentRuntime): void {\n        const endpoints: RPCEndpoint[] = [];\n        \n        // Primary endpoints from configuration\n        const primaryRPC = runtime.getSetting(\"UNISWAP_RPC_URL\") || \n                          runtime.getSetting(\"ETHEREUM_RPC_URL\") || \n                          runtime.getSetting(\"ETHEREUM_PROVIDER_URL\");\n        \n        if (primaryRPC) {\n            endpoints.push({ name: \"Primary\", url: primaryRPC, priority: 1 });\n        }\n        \n        // Backup endpoints from configuration\n        const backupRPC1 = runtime.getSetting(\"ETHEREUM_RPC_URL_BACKUP\");\n        const backupRPC2 = runtime.getSetting(\"ETHEREUM_RPC_URL_BACKUP2\");\n        \n        if (backupRPC1) {\n            endpoints.push({ name: \"Backup1\", url: backupRPC1, priority: 2 });\n        }\n        if (backupRPC2) {\n            endpoints.push({ name: \"Backup2\", url: backupRPC2, priority: 3 });\n        }\n        \n        // Additional reliable public endpoints as fallbacks\n        endpoints.push(\n            { name: \"Cloudflare\", url: \"https://cloudflare-eth.com\", priority: 4 },\n            { name: \"PublicNode\", url: \"https://ethereum.publicnode.com\", priority: 5 },\n            { name: \"LlamaRPC\", url: \"https://eth.llamarpc.com\", priority: 6 }\n        );\n        \n        // Sort by priority\n        this.rpcEndpoints = endpoints.sort((a, b) => a.priority - b.priority);\n        \n        logger.info(`Configured ${this.rpcEndpoints.length} RPC endpoints`);\n    }\n\n    private async initializeProviders(): Promise<void> {\n        const workingProviders: RPCEndpoint[] = [];\n        \n        for (const endpoint of this.rpcEndpoints) {\n            try {\n                const provider = new ethers.JsonRpcProvider(endpoint.url);\n                \n                // Test connectivity with timeout\n                const timeoutPromise = new Promise((_, reject) => \n                    setTimeout(() => reject(new Error('Timeout')), 5000)\n                );\n                \n                const testPromise = provider.getNetwork();\n                const network = await Promise.race([testPromise, timeoutPromise]) as any;\n                \n                // Verify it's Ethereum mainnet (chain ID 1)\n                if (network.chainId === 1n) {\n                    this.providers.set(endpoint.name, provider);\n                    workingProviders.push(endpoint);\n                    logger.info(`‚úÖ ${endpoint.name} RPC working (${endpoint.url})`);\n                    \n                    // Set the first working provider as current\n                    if (!this.currentProvider) {\n                        this.currentProvider = provider;\n                        logger.info(`Using ${endpoint.name} as primary RPC provider`);\n                    }\n                } else {\n                    logger.warn(`‚ö†Ô∏è ${endpoint.name} connected to wrong network (Chain ID: ${network.chainId})`);\n                }\n                \n            } catch (error) {\n                logger.warn(`‚ùå ${endpoint.name} RPC failed: ${error instanceof Error ? error.message : String(error)}`);\n            }\n        }\n        \n        if (workingProviders.length === 0) {\n            throw new Error(\"No working RPC endpoints found. Please check your internet connection and RPC configuration.\");\n        }\n        \n        logger.info(`Successfully initialized ${workingProviders.length} working RPC providers`);\n    }\n\n    private async setupWallet(runtime: IAgentRuntime): Promise<void> {\n        const privateKey = runtime.getSetting(\"EVM_PRIVATE_KEY\") || runtime.getSetting(\"WALLET_PRIVATE_KEY\");\n        \n        if (!privateKey) {\n            logger.warn(\"No private key configured - read-only mode\");\n            return;\n        }\n        \n        if (!this.currentProvider) {\n            throw new Error(\"No working RPC provider available for wallet setup\");\n        }\n        \n        try {\n            const formattedKey = privateKey.startsWith('0x') ? privateKey : `0x${privateKey}`;\n            this.wallet = new ethers.Wallet(formattedKey, this.currentProvider);\n            \n            // Test wallet by checking balance\n            const balance = await this.wallet.provider.getBalance(this.wallet.address);\n            logger.info(`Wallet initialized: ${this.wallet.address} (${ethers.formatEther(balance)} ETH)`);\n            \n        } catch (error) {\n            throw new Error(`Failed to initialize wallet: ${error instanceof Error ? error.message : String(error)}`);\n        }\n    }\n\n    private async executeWithRetry<T>(\n        operation: (provider: ethers.JsonRpcProvider) => Promise<T>,\n        maxRetries: number = 3,\n        operationName: string = \"RPC call\"\n    ): Promise<T> {\n        const providers = Array.from(this.providers.values());\n        let lastError: Error | null = null;\n        \n        for (let attempt = 0; attempt < maxRetries; attempt++) {\n            for (const provider of providers) {\n                try {\n                    logger.debug(`${operationName} attempt ${attempt + 1} with provider`);\n                    const result = await operation(provider);\n                    \n                    // Update current provider if this one worked\n                    this.currentProvider = provider;\n                    \n                    return result;\n                } catch (error) {\n                    lastError = error instanceof Error ? error : new Error(String(error));\n                    logger.warn(`${operationName} failed with provider: ${lastError.message}`);\n                    \n                    // If it's a \"no response\" error, try next provider immediately\n                    if (lastError.message.includes('no response') || \n                        lastError.message.includes('timeout') ||\n                        lastError.message.includes('TIMEOUT')) {\n                        continue;\n                    }\n                    \n                    // For other errors, might be worth retrying with same provider\n                    if (attempt < maxRetries - 1) {\n                        await new Promise(resolve => setTimeout(resolve, 1000 * (attempt + 1))); // Exponential backoff\n                    }\n                }\n            }\n        }\n        \n        throw new Error(`${operationName} failed after ${maxRetries} attempts across all providers. Last error: ${lastError?.message || 'Unknown error'}`);\n    }\n\n    /**\n     * Get a quote for swapping tokenIn to tokenOut\n     */\n    async getQuote(tokenInSymbol: string, tokenOutSymbol: string, amountIn: string): Promise<string> {\n        const tokenIn = getTokenBySymbol(tokenInSymbol);\n        const tokenOut = getTokenBySymbol(tokenOutSymbol);\n\n        if (!tokenIn || !tokenOut) {\n            throw new Error(`Token configuration not found for ${tokenInSymbol} or ${tokenOutSymbol}`);\n        }\n\n        return await this.executeWithRetry(async (provider) => {\n            const quoter = new ethers.Contract(QUOTER_ADDRESS, QUOTE_ABI, provider);\n\n            // Construct PoolKey (Simplified assuming direct pool exists with standard fee)\n            const poolKey = {\n                currency0: tokenIn.address < tokenOut.address ? tokenIn.address : tokenOut.address,\n                currency1: tokenIn.address < tokenOut.address ? tokenOut.address : tokenIn.address,\n                fee: 3000, // Default 0.3%\n                tickSpacing: 60,\n                hooks: ethers.ZeroAddress\n            };\n\n            const zeroForOne = tokenIn.address === poolKey.currency0;\n            const amountInParsed = ethers.parseUnits(amountIn, tokenIn.decimals);\n\n            // Using callStatic to simulate\n            const result = await quoter.quoteExactInputSingle.staticCall(\n                poolKey,\n                zeroForOne,\n                amountInParsed,\n                \"0x\" // No hook data\n            );\n\n            return ethers.formatUnits(result.amountOut, tokenOut.decimals);\n        }, 3, `Quote for ${tokenInSymbol} -> ${tokenOutSymbol}`);\n    }\n\n    /**\n     * Execute a swap using SwapRouter02 (Uniswap V3) with enhanced error handling\n     */\n    async executeSwap(tokenInSymbol: string, tokenOutSymbol: string, amountIn: string): Promise<string> {\n        if (!this.wallet) throw new Error(\"Wallet not initialized with private key\");\n\n        const tokenIn = getTokenBySymbol(tokenInSymbol);\n        const tokenOut = getTokenBySymbol(tokenOutSymbol);\n\n        if (!tokenIn || !tokenOut) {\n            throw new Error(`Token configuration not found for ${tokenInSymbol} or ${tokenOutSymbol}`);\n        }\n\n        const SWAP_ROUTER_02_ADDRESS = \"0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45\";\n        const amountInWei = ethers.parseUnits(amountIn, tokenIn.decimals);\n\n        // 1. Check Balance and Allowance with retry\n        if (tokenInSymbol !== 'ETH' && tokenInSymbol !== 'WETH') {\n            await this.executeWithRetry(async (provider) => {\n                // Update wallet provider to current working provider\n                this.wallet = new ethers.Wallet(this.wallet!.privateKey, provider);\n                \n                const tokenContract = new ethers.Contract(tokenIn.address, [\n                    \"function balanceOf(address) view returns (uint256)\",\n                    \"function allowance(address, address) view returns (uint256)\",\n                    \"function approve(address, uint256) returns (bool)\"\n                ], this.wallet);\n\n                // Verify contract exists\n                const code = await provider.getCode(tokenIn.address);\n                if (code === '0x') {\n                    throw new Error(`Token contract ${tokenInSymbol} not found at ${tokenIn.address} on this chain`);\n                }\n\n                const balance = await tokenContract.balanceOf(this.wallet.address);\n                if (balance < amountInWei) {\n                    throw new Error(`Insufficient balance of ${tokenInSymbol}. Have ${ethers.formatUnits(balance, tokenIn.decimals)}, need ${amountIn}`);\n                }\n\n                const allowance = await tokenContract.allowance(this.wallet.address, SWAP_ROUTER_02_ADDRESS);\n                if (allowance < amountInWei) {\n                    logger.info(`Approving ${tokenInSymbol} for Uniswap Router...`);\n                    const tx = await tokenContract.approve(SWAP_ROUTER_02_ADDRESS, ethers.MaxUint256);\n                    logger.info(`Approval tx sent: ${tx.hash}`);\n                    await tx.wait();\n                    logger.info(\"Approval confirmed\");\n                }\n                \n                return true; // Success indicator\n            }, 3, `Balance and allowance check for ${tokenInSymbol}`);\n        } else if (tokenInSymbol === 'ETH') {\n            await this.executeWithRetry(async (provider) => {\n                const balance = await provider.getBalance(this.wallet!.address);\n                if (balance < amountInWei) {\n                    throw new Error(`Insufficient ETH balance. Have ${ethers.formatEther(balance)}, need ${amountIn}`);\n                }\n                return true;\n            }, 3, \"ETH balance check\");\n        }\n\n        // 2. Execute Swap with retry\n        logger.info(`Executing swap: ${amountIn} ${tokenInSymbol} -> ${tokenOutSymbol}`);\n\n        return await this.executeWithRetry(async (provider) => {\n            // Update wallet provider to current working provider\n            this.wallet = new ethers.Wallet(this.wallet!.privateKey, provider);\n            \n            const router = new ethers.Contract(SWAP_ROUTER_02_ADDRESS, [\n                \"function exactInputSingle((address tokenIn, address tokenOut, uint24 fee, address recipient, uint256 amountIn, uint256 amountOutMinimum, uint160 sqrtPriceLimitX96)) external payable returns (uint256 amountOut)\"\n            ], this.wallet);\n\n            const params = {\n                tokenIn: tokenIn.address,\n                tokenOut: tokenOut.address,\n                fee: 3000, // 0.3% pool fee\n                recipient: this.wallet.address,\n                amountIn: amountInWei,\n                amountOutMinimum: 0, // No slippage protection for demo simplicity\n                sqrtPriceLimitX96: 0\n            };\n\n            const overrides = tokenInSymbol === 'ETH' ? { value: amountInWei } : {};\n\n            const tx = await router.exactInputSingle(params, overrides);\n            logger.info(`Swap transaction sent: ${tx.hash}`);\n\n            // Wait for confirmation\n            const receipt = await tx.wait();\n            logger.info(`Swap confirmed in block ${receipt.blockNumber}`);\n\n            return tx.hash;\n        }, 2, `Swap execution for ${tokenInSymbol} -> ${tokenOutSymbol}`); // Fewer retries for actual transactions\n    }\n}","import { Plugin } from \"@elizaos/core\";\nimport { getQuoteAction } from \"./actions/quote\";\nimport { swapTokensAction } from \"./actions/swap\";\nimport { enhancedSwapTokensAction } from \"./actions/enhancedSwap\";\n\nexport const uniswapPlugin: Plugin = {\n    name: \"uniswap\",\n    description: \"Enhanced Uniswap V4 Plugin for Swapping and Quoting with Robust RPC Handling\",\n    actions: [\n        getQuoteAction,\n        swapTokensAction,\n        enhancedSwapTokensAction // Enhanced version with better error handling\n    ],\n    evaluators: [],\n    providers: [],\n};\n\nexport default uniswapPlugin;\n"],"mappings":";AAAA,SAA8E,mBAAmB;;;ACAjG,SAAS,SAAwB,cAAc;AAC/C,SAAS,cAAc;;;ACDvB,SAAS,OAAO,eAAe;AAGxB,IAAM,WAAW,QAAQ;AAOzB,IAAM,YAAY,IAAI;AAAA,EACzB;AAAA,EACA;AAAA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACJ;AAEO,IAAM,aAAa,IAAI;AAAA,EAC1B;AAAA,EACA;AAAA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACJ;AAGO,IAAM,aAA0B;AAAA,EACnC,UAAU,IAAI;AAAA,IACV;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACJ;AAAA,EACA,kBAAkB,IAAI;AAAA,IAClB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACJ;AAAA,EACA,UAAU,IAAI;AAAA,IACV;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACJ;AAAA,EACA,UAAU,IAAI;AAAA,IACV;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACJ;AAAA,EACA,SAAS,IAAI;AAAA,IACT;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACJ;AAAA,EACA,SAAS,IAAI;AAAA,IACT;AAAA,IACA;AAAA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACJ;AAAA,EACA,SAAS,IAAI;AAAA,IACT;AAAA,IACA;AAAA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACJ;AACJ;AAGO,IAAM,SAAsB;AAAA,EAC/B,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,GAAG;AACP;AAEO,IAAM,mBAAmB,CAAC,WAAsC;AACnE,QAAM,mBAAmB,OAAO,YAAY;AAC5C,SAAO,OAAO,gBAAgB;AAClC;;;ADnFA,IAAM,iBAAiB;AAKvB,IAAM,YAAY;AAAA,EACd;AAAA,EACA;AACJ;AAEO,IAAM,iBAAN,cAA6B,QAAQ;AAAA,EAArC;AAAA;AAEH,iCAAwB;AACxB,SAAQ,WAA0C;AAClD,SAAQ,SAA+B;AAAA;AAAA,EAEvC,MAAM,OAAsB;AACxB,SAAK,WAAW;AAChB,SAAK,SAAS;AAAA,EAClB;AAAA,EAEA,MAAM,WAAW,SAAuC;AACpD,UAAM,SACF,QAAQ,WAAW,uBAAuB,KAC1C,QAAQ,WAAW,kBAAkB,KACrC,QAAQ,WAAW,iBAAiB,KACpC,QAAQ,WAAW,cAAc;AAErC,QAAI,CAAC,OAAQ,OAAM,IAAI,MAAM,sEAAsE;AAEnG,SAAK,WAAW,IAAI,OAAO,gBAAgB,MAAM;AAEjD,UAAM,aAAa,QAAQ,WAAW,iBAAiB,KAAK,QAAQ,WAAW,oBAAoB;AACnG,QAAI,YAAY;AACZ,WAAK,SAAS,IAAI,OAAO,OAAO,YAAY,KAAK,QAAQ;AAAA,IAC7D;AAEA,UAAM,UAAU,MAAM,KAAK,SAAS,WAAW;AAC/C,WAAO,KAAK,4CAA4C,QAAQ,OAAO,EAAE;AAAA,EAC7E;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,SAAS,eAAuB,gBAAwB,UAAmC;AAC7F,QAAI,CAAC,KAAK,SAAU,OAAM,IAAI,MAAM,0BAA0B;AAE9D,UAAM,UAAU,iBAAiB,aAAa;AAC9C,UAAM,WAAW,iBAAiB,cAAc;AAEhD,QAAI,CAAC,WAAW,CAAC,UAAU;AACvB,YAAM,IAAI,MAAM,qCAAqC,aAAa,OAAO,cAAc,EAAE;AAAA,IAC7F;AAEA,UAAM,SAAS,IAAI,OAAO,SAAS,gBAAgB,WAAW,KAAK,QAAQ;AAI3E,UAAM,UAAU;AAAA,MACZ,WAAW,QAAQ,UAAU,SAAS,UAAU,QAAQ,UAAU,SAAS;AAAA,MAC3E,WAAW,QAAQ,UAAU,SAAS,UAAU,SAAS,UAAU,QAAQ;AAAA,MAC3E,KAAK;AAAA;AAAA,MACL,aAAa;AAAA,MACb,OAAO,OAAO;AAAA,IAClB;AAEA,UAAM,aAAa,QAAQ,YAAY,QAAQ;AAC/C,UAAM,iBAAiB,OAAO,WAAW,UAAU,QAAQ,QAAQ;AAEnE,QAAI;AAEA,YAAM,SAAS,MAAM,OAAO,sBAAsB;AAAA,QAC9C;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA;AAAA,MACJ;AAEA,YAAM,YAAY,OAAO,YAAY,OAAO,WAAW,SAAS,QAAQ;AACxE,aAAO;AAAA,IACX,SAAS,OAAY;AACjB,aAAO,MAAM,yBAAyB,KAAK;AAC3C,YAAM,IAAI,MAAM,0BAA0B,MAAM,OAAO,EAAE;AAAA,IAC7D;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,YAAY,eAAuB,gBAAwB,UAAmC;AAChG,QAAI,CAAC,KAAK,OAAQ,OAAM,IAAI,MAAM,yCAAyC;AAE3E,UAAM,UAAU,iBAAiB,aAAa;AAC9C,UAAM,WAAW,iBAAiB,cAAc;AAEhD,QAAI,CAAC,WAAW,CAAC,UAAU;AACvB,YAAM,IAAI,MAAM,qCAAqC,aAAa,OAAO,cAAc,EAAE;AAAA,IAC7F;AAEA,UAAM,yBAAyB;AAC/B,UAAM,cAAc,OAAO,WAAW,UAAU,QAAQ,QAAQ;AAGhE,QAAI,kBAAkB,SAAS,kBAAkB,QAAQ;AACrD,YAAM,gBAAgB,IAAI,OAAO,SAAS,QAAQ,SAAS;AAAA,QACvD;AAAA,QACA;AAAA,QACA;AAAA,MACJ,GAAG,KAAK,MAAM;AAGd,YAAM,OAAO,MAAM,KAAK,SAAU,QAAQ,QAAQ,OAAO;AACzD,UAAI,SAAS,MAAM;AACf,cAAM,IAAI,MAAM,kBAAkB,aAAa,iBAAiB,QAAQ,OAAO,2CAA2C;AAAA,MAC9H;AAEA,YAAM,UAAU,MAAM,cAAc,UAAU,KAAK,OAAO,OAAO;AACjE,UAAI,UAAU,aAAa;AACvB,cAAM,IAAI,MAAM,2BAA2B,aAAa,UAAU,OAAO,YAAY,SAAS,QAAQ,QAAQ,CAAC,UAAU,QAAQ,EAAE;AAAA,MACvI;AAEA,YAAM,YAAY,MAAM,cAAc,UAAU,KAAK,OAAO,SAAS,sBAAsB;AAC3F,UAAI,YAAY,aAAa;AACzB,eAAO,KAAK,aAAa,aAAa,wBAAwB;AAC9D,cAAM,KAAK,MAAM,cAAc,QAAQ,wBAAwB,OAAO,UAAU;AAChF,eAAO,KAAK,qBAAqB,GAAG,IAAI,EAAE;AAC1C,cAAM,GAAG,KAAK;AACd,eAAO,KAAK,oBAAoB;AAAA,MACpC;AAAA,IACJ,WAAW,kBAAkB,OAAO;AAChC,YAAM,UAAU,MAAM,KAAK,SAAU,WAAW,KAAK,OAAO,OAAO;AACnE,UAAI,UAAU,aAAa;AACvB,cAAM,IAAI,MAAM,kCAAkC,OAAO,YAAY,OAAO,CAAC,UAAU,QAAQ,EAAE;AAAA,MACrG;AAAA,IACJ;AAGA,WAAO,KAAK,mBAAmB,QAAQ,IAAI,aAAa,OAAO,cAAc,EAAE;AAE/E,UAAM,SAAS,IAAI,OAAO,SAAS,wBAAwB;AAAA,MACvD;AAAA,IACJ,GAAG,KAAK,MAAM;AAEd,UAAM,SAAS;AAAA,MACX,SAAS,QAAQ;AAAA,MACjB,UAAU,SAAS;AAAA,MACnB,KAAK;AAAA;AAAA,MACL,WAAW,KAAK,OAAO;AAAA,MACvB,UAAU;AAAA,MACV,kBAAkB;AAAA;AAAA,MAClB,mBAAmB;AAAA,IACvB;AAEA,UAAM,YAAY,kBAAkB,QAAQ,EAAE,OAAO,YAAY,IAAI,CAAC;AAEtE,QAAI;AACA,YAAM,KAAK,MAAM,OAAO,iBAAiB,QAAQ,SAAS;AAC1D,aAAO,KAAK,0BAA0B,GAAG,IAAI,EAAE;AAG/C,YAAM,UAAU,MAAM,GAAG,KAAK;AAC9B,aAAO,KAAK,2BAA2B,QAAQ,WAAW,EAAE;AAE5D,aAAO,GAAG;AAAA,IACd,SAAS,OAAY;AACjB,aAAO,MAAM,sCAAsC,KAAK;AACxD,YAAM,IAAI,MAAM,4BAA4B,MAAM,UAAU,MAAM,OAAO,EAAE;AAAA,IAC/E;AAAA,EACJ;AACJ;AA/Ja,eACF,cAAc;;;ADdlB,IAAM,iBAAyB;AAAA,EAClC,MAAM;AAAA,EACN,SAAS,CAAC,eAAe,eAAe,aAAa;AAAA,EACrD,aAAa;AAAA,EACb,UAAU,OAAO,SAAwB,YAAoB;AACzD,WAAO,CAAC,CAAC,QAAQ,WAAW,iBAAiB,KAAK,CAAC,CAAC,QAAQ,WAAW,oBAAoB;AAAA,EAC/F;AAAA,EACA,SAAS,OACL,SACA,SACA,OACA,SACA,aACC;AACD,gBAAY,KAAK,2BAA2B;AAE5C,UAAM,UAAU,QAAQ,QAAQ,QAAQ;AACxC,UAAM,cAAc,QAAQ,MAAM,eAAe;AACjD,UAAM,SAAS,cAAc,YAAY,CAAC,IAAI;AAE9C,UAAM,QAAQ,QAAQ,MAAM,GAAG;AAC/B,UAAM,UAAU,MACX,IAAI,OAAK,EAAE,KAAK,EAAE,QAAQ,SAAS,EAAE,CAAC,EACtC,OAAO,OAAK,iBAAiB,CAAC,CAAC;AAEpC,UAAM,UAAU,QAAQ,CAAC,KAAK;AAC9B,UAAM,WAAW,QAAQ,CAAC,KAAK;AAE/B,QAAI;AACA,YAAM,UAAU,IAAI,eAAe,OAAO;AAC1C,YAAM,QAAQ,WAAW,OAAO;AAEhC,YAAM,QAAQ,MAAM,QAAQ,SAAS,SAAS,UAAU,MAAM;AAE9D,UAAI,UAAU;AACV,iBAAS;AAAA,UACL,MAAM,UAAU,MAAM,IAAI,OAAO,WAAM,KAAK,IAAI,QAAQ;AAAA,QAC5D,CAAC;AAAA,MACL;AACA,aAAO,EAAE,SAAS,MAAM,MAAM,UAAU,MAAM,IAAI,OAAO,WAAM,KAAK,IAAI,QAAQ,IAAI,MAAM,EAAE,QAAQ,SAAS,UAAU,MAAM,EAAE;AAAA,IACnI,SAAS,OAAY;AACjB,kBAAY,MAAM,+BAA+B,KAAK;AACtD,UAAI,UAAU;AACV,iBAAS;AAAA,UACL,MAAM,wBAAwB,MAAM,OAAO;AAAA,QAC/C,CAAC;AAAA,MACL;AACA,aAAO,EAAE,SAAS,OAAO,OAAO,OAAO,WAAW,gBAAgB;AAAA,IACtE;AAAA,EACJ;AAAA,EACA,UAAU;AAAA,IACN;AAAA,MACI;AAAA,QACI,MAAM;AAAA,QACN,SAAS,EAAE,MAAM,8BAA8B;AAAA,MACnD;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,UACN,QAAQ;AAAA,QACZ;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AACJ;;;AGrEA,SAA8E,eAAAA,oBAAmB;AAI1F,IAAM,mBAA2B;AAAA,EACpC,MAAM;AAAA,EACN,SAAS,CAAC,eAAe,QAAQ,SAAS,UAAU;AAAA,EACpD,aAAa;AAAA,EACb,UAAU,OAAO,SAAwB,YAAoB;AACzD,WAAO,CAAC,CAAC,QAAQ,WAAW,iBAAiB,KAAK,CAAC,CAAC,QAAQ,WAAW,oBAAoB;AAAA,EAC/F;AAAA,EACA,SAAS,OACL,SACA,SACA,OACA,SACA,aACC;AACD,IAAAC,aAAY,KAAK,6BAA6B;AAE9C,UAAM,UAAU,QAAQ,QAAQ,QAAQ;AACxC,UAAM,cAAc,QAAQ,MAAM,eAAe;AACjD,UAAM,SAAS,cAAc,YAAY,CAAC,IAAI;AAG9C,UAAM,oBAAoB,QAAQ,QAAQ,QAAQ,EAAE;AAEpD,UAAM,QAAQ,kBAAkB,MAAM,GAAG;AACzC,UAAM,UAAU,MACX,IAAI,OAAK,EAAE,KAAK,EAAE,QAAQ,SAAS,EAAE,CAAC,EACtC,OAAO,OAAK,iBAAiB,CAAC,CAAC;AAGpC,QAAI,UAAU,QAAQ,CAAC;AACvB,QAAI,WAAW,QAAQ,CAAC;AAExB,QAAI,CAAC,QAAS,WAAU;AACxB,QAAI,CAAC,SAAU,YAAW;AAE1B,UAAM,YAAY,WAAW,MAAM;AACnC,QAAI,CAAC,eAAe,MAAM,SAAS,KAAK,aAAa,GAAG;AACpD,UAAI,UAAU;AACV,iBAAS;AAAA,UACL,MAAM;AAAA,QACV,CAAC;AAAA,MACL;AACA,aAAO,EAAE,SAAS,OAAO,OAAO,iCAAiC;AAAA,IACrE;AAEA,QAAI;AACA,YAAM,UAAU,IAAI,eAAe,OAAO;AAC1C,YAAM,QAAQ,WAAW,OAAO;AAEhC,YAAM,SAAS,MAAM,QAAQ,YAAY,SAAS,UAAU,MAAM;AAElE,UAAI,UAAU;AACV,iBAAS;AAAA,UACL,MAAM,oCAAoC,MAAM;AAAA,QACpD,CAAC;AAAA,MACL;AACA,aAAO,EAAE,SAAS,MAAM,MAAM,sBAAsB,MAAM,IAAI,MAAM,EAAE,QAAQ,SAAS,UAAU,OAAO,EAAE;AAAA,IAC9G,SAAS,OAAY;AACjB,MAAAA,aAAY,MAAM,iCAAiC,KAAK;AACxD,UAAI,UAAU;AACV,iBAAS;AAAA,UACL,MAAM,2BAA2B,MAAM,OAAO;AAAA,QAClD,CAAC;AAAA,MACL;AACA,aAAO,EAAE,SAAS,OAAO,OAAO,OAAO,WAAW,gBAAgB;AAAA,IACtE;AAAA,EACJ;AAAA,EACA,UAAU;AAAA,IACN;AAAA,MACI;AAAA,QACI,MAAM;AAAA,QACN,SAAS,EAAE,MAAM,uBAAuB;AAAA,MAC5C;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,UACN,QAAQ;AAAA,QACZ;AAAA,MACJ;AAAA,IACJ;AAAA,IACA;AAAA,MACI;AAAA,QACI,MAAM;AAAA,QACN,SAAS,EAAE,MAAM,yBAAyB;AAAA,MAC9C;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,UACN,QAAQ;AAAA,QACZ;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AACJ;;;ACnGA,SAA8E,eAAAC,oBAAmB;;;ACAjG,SAAS,WAAAC,UAAwB,UAAAC,eAAc;AAC/C,SAAS,UAAAC,eAAc;AAMvB,IAAMC,kBAAiB;AAKvB,IAAMC,aAAY;AAAA,EACd;AAAA,EACA;AACJ;AAQO,IAAM,yBAAN,cAAqCC,SAAQ;AAAA,EAA7C;AAAA;AAEH,iCAAwB;AACxB,SAAQ,YAAiD,oBAAI,IAAI;AACjE,SAAQ,SAA+B;AACvC,SAAQ,eAA8B,CAAC;AACvC,SAAQ,kBAAiD;AAAA;AAAA,EAEzD,MAAM,OAAsB;AACxB,SAAK,UAAU,MAAM;AACrB,SAAK,SAAS;AACd,SAAK,kBAAkB;AACvB,SAAK,eAAe,CAAC;AAAA,EACzB;AAAA,EAEA,MAAM,WAAW,SAAuC;AAEpD,SAAK,kBAAkB,OAAO;AAG9B,UAAM,KAAK,oBAAoB;AAG/B,UAAM,KAAK,YAAY,OAAO;AAE9B,IAAAC,QAAO,KAAK,6CAA6C,KAAK,UAAU,IAAI,gBAAgB;AAAA,EAChG;AAAA,EAEQ,kBAAkB,SAA8B;AACpD,UAAM,YAA2B,CAAC;AAGlC,UAAM,aAAa,QAAQ,WAAW,iBAAiB,KACrC,QAAQ,WAAW,kBAAkB,KACrC,QAAQ,WAAW,uBAAuB;AAE5D,QAAI,YAAY;AACZ,gBAAU,KAAK,EAAE,MAAM,WAAW,KAAK,YAAY,UAAU,EAAE,CAAC;AAAA,IACpE;AAGA,UAAM,aAAa,QAAQ,WAAW,yBAAyB;AAC/D,UAAM,aAAa,QAAQ,WAAW,0BAA0B;AAEhE,QAAI,YAAY;AACZ,gBAAU,KAAK,EAAE,MAAM,WAAW,KAAK,YAAY,UAAU,EAAE,CAAC;AAAA,IACpE;AACA,QAAI,YAAY;AACZ,gBAAU,KAAK,EAAE,MAAM,WAAW,KAAK,YAAY,UAAU,EAAE,CAAC;AAAA,IACpE;AAGA,cAAU;AAAA,MACN,EAAE,MAAM,cAAc,KAAK,8BAA8B,UAAU,EAAE;AAAA,MACrE,EAAE,MAAM,cAAc,KAAK,mCAAmC,UAAU,EAAE;AAAA,MAC1E,EAAE,MAAM,YAAY,KAAK,4BAA4B,UAAU,EAAE;AAAA,IACrE;AAGA,SAAK,eAAe,UAAU,KAAK,CAAC,GAAG,MAAM,EAAE,WAAW,EAAE,QAAQ;AAEpE,IAAAA,QAAO,KAAK,cAAc,KAAK,aAAa,MAAM,gBAAgB;AAAA,EACtE;AAAA,EAEA,MAAc,sBAAqC;AAC/C,UAAM,mBAAkC,CAAC;AAEzC,eAAW,YAAY,KAAK,cAAc;AACtC,UAAI;AACA,cAAM,WAAW,IAAIC,QAAO,gBAAgB,SAAS,GAAG;AAGxD,cAAM,iBAAiB,IAAI;AAAA,UAAQ,CAAC,GAAG,WACnC,WAAW,MAAM,OAAO,IAAI,MAAM,SAAS,CAAC,GAAG,GAAI;AAAA,QACvD;AAEA,cAAM,cAAc,SAAS,WAAW;AACxC,cAAM,UAAU,MAAM,QAAQ,KAAK,CAAC,aAAa,cAAc,CAAC;AAGhE,YAAI,QAAQ,YAAY,IAAI;AACxB,eAAK,UAAU,IAAI,SAAS,MAAM,QAAQ;AAC1C,2BAAiB,KAAK,QAAQ;AAC9B,UAAAD,QAAO,KAAK,UAAK,SAAS,IAAI,iBAAiB,SAAS,GAAG,GAAG;AAG9D,cAAI,CAAC,KAAK,iBAAiB;AACvB,iBAAK,kBAAkB;AACvB,YAAAA,QAAO,KAAK,SAAS,SAAS,IAAI,0BAA0B;AAAA,UAChE;AAAA,QACJ,OAAO;AACH,UAAAA,QAAO,KAAK,gBAAM,SAAS,IAAI,0CAA0C,QAAQ,OAAO,GAAG;AAAA,QAC/F;AAAA,MAEJ,SAAS,OAAO;AACZ,QAAAA,QAAO,KAAK,UAAK,SAAS,IAAI,gBAAgB,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC,EAAE;AAAA,MAC1G;AAAA,IACJ;AAEA,QAAI,iBAAiB,WAAW,GAAG;AAC/B,YAAM,IAAI,MAAM,8FAA8F;AAAA,IAClH;AAEA,IAAAA,QAAO,KAAK,4BAA4B,iBAAiB,MAAM,wBAAwB;AAAA,EAC3F;AAAA,EAEA,MAAc,YAAY,SAAuC;AAC7D,UAAM,aAAa,QAAQ,WAAW,iBAAiB,KAAK,QAAQ,WAAW,oBAAoB;AAEnG,QAAI,CAAC,YAAY;AACb,MAAAA,QAAO,KAAK,4CAA4C;AACxD;AAAA,IACJ;AAEA,QAAI,CAAC,KAAK,iBAAiB;AACvB,YAAM,IAAI,MAAM,oDAAoD;AAAA,IACxE;AAEA,QAAI;AACA,YAAM,eAAe,WAAW,WAAW,IAAI,IAAI,aAAa,KAAK,UAAU;AAC/E,WAAK,SAAS,IAAIC,QAAO,OAAO,cAAc,KAAK,eAAe;AAGlE,YAAM,UAAU,MAAM,KAAK,OAAO,SAAS,WAAW,KAAK,OAAO,OAAO;AACzE,MAAAD,QAAO,KAAK,uBAAuB,KAAK,OAAO,OAAO,KAAKC,QAAO,YAAY,OAAO,CAAC,OAAO;AAAA,IAEjG,SAAS,OAAO;AACZ,YAAM,IAAI,MAAM,gCAAgC,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC,EAAE;AAAA,IAC5G;AAAA,EACJ;AAAA,EAEA,MAAc,iBACV,WACA,aAAqB,GACrB,gBAAwB,YACd;AACV,UAAM,YAAY,MAAM,KAAK,KAAK,UAAU,OAAO,CAAC;AACpD,QAAI,YAA0B;AAE9B,aAAS,UAAU,GAAG,UAAU,YAAY,WAAW;AACnD,iBAAW,YAAY,WAAW;AAC9B,YAAI;AACA,UAAAD,QAAO,MAAM,GAAG,aAAa,YAAY,UAAU,CAAC,gBAAgB;AACpE,gBAAM,SAAS,MAAM,UAAU,QAAQ;AAGvC,eAAK,kBAAkB;AAEvB,iBAAO;AAAA,QACX,SAAS,OAAO;AACZ,sBAAY,iBAAiB,QAAQ,QAAQ,IAAI,MAAM,OAAO,KAAK,CAAC;AACpE,UAAAA,QAAO,KAAK,GAAG,aAAa,0BAA0B,UAAU,OAAO,EAAE;AAGzE,cAAI,UAAU,QAAQ,SAAS,aAAa,KACxC,UAAU,QAAQ,SAAS,SAAS,KACpC,UAAU,QAAQ,SAAS,SAAS,GAAG;AACvC;AAAA,UACJ;AAGA,cAAI,UAAU,aAAa,GAAG;AAC1B,kBAAM,IAAI,QAAQ,aAAW,WAAW,SAAS,OAAQ,UAAU,EAAE,CAAC;AAAA,UAC1E;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAEA,UAAM,IAAI,MAAM,GAAG,aAAa,iBAAiB,UAAU,+CAA+C,WAAW,WAAW,eAAe,EAAE;AAAA,EACrJ;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,SAAS,eAAuB,gBAAwB,UAAmC;AAC7F,UAAM,UAAU,iBAAiB,aAAa;AAC9C,UAAM,WAAW,iBAAiB,cAAc;AAEhD,QAAI,CAAC,WAAW,CAAC,UAAU;AACvB,YAAM,IAAI,MAAM,qCAAqC,aAAa,OAAO,cAAc,EAAE;AAAA,IAC7F;AAEA,WAAO,MAAM,KAAK,iBAAiB,OAAO,aAAa;AACnD,YAAM,SAAS,IAAIC,QAAO,SAASC,iBAAgBJ,YAAW,QAAQ;AAGtE,YAAM,UAAU;AAAA,QACZ,WAAW,QAAQ,UAAU,SAAS,UAAU,QAAQ,UAAU,SAAS;AAAA,QAC3E,WAAW,QAAQ,UAAU,SAAS,UAAU,SAAS,UAAU,QAAQ;AAAA,QAC3E,KAAK;AAAA;AAAA,QACL,aAAa;AAAA,QACb,OAAOG,QAAO;AAAA,MAClB;AAEA,YAAM,aAAa,QAAQ,YAAY,QAAQ;AAC/C,YAAM,iBAAiBA,QAAO,WAAW,UAAU,QAAQ,QAAQ;AAGnE,YAAM,SAAS,MAAM,OAAO,sBAAsB;AAAA,QAC9C;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA;AAAA,MACJ;AAEA,aAAOA,QAAO,YAAY,OAAO,WAAW,SAAS,QAAQ;AAAA,IACjE,GAAG,GAAG,aAAa,aAAa,OAAO,cAAc,EAAE;AAAA,EAC3D;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,YAAY,eAAuB,gBAAwB,UAAmC;AAChG,QAAI,CAAC,KAAK,OAAQ,OAAM,IAAI,MAAM,yCAAyC;AAE3E,UAAM,UAAU,iBAAiB,aAAa;AAC9C,UAAM,WAAW,iBAAiB,cAAc;AAEhD,QAAI,CAAC,WAAW,CAAC,UAAU;AACvB,YAAM,IAAI,MAAM,qCAAqC,aAAa,OAAO,cAAc,EAAE;AAAA,IAC7F;AAEA,UAAM,yBAAyB;AAC/B,UAAM,cAAcA,QAAO,WAAW,UAAU,QAAQ,QAAQ;AAGhE,QAAI,kBAAkB,SAAS,kBAAkB,QAAQ;AACrD,YAAM,KAAK,iBAAiB,OAAO,aAAa;AAE5C,aAAK,SAAS,IAAIA,QAAO,OAAO,KAAK,OAAQ,YAAY,QAAQ;AAEjE,cAAM,gBAAgB,IAAIA,QAAO,SAAS,QAAQ,SAAS;AAAA,UACvD;AAAA,UACA;AAAA,UACA;AAAA,QACJ,GAAG,KAAK,MAAM;AAGd,cAAM,OAAO,MAAM,SAAS,QAAQ,QAAQ,OAAO;AACnD,YAAI,SAAS,MAAM;AACf,gBAAM,IAAI,MAAM,kBAAkB,aAAa,iBAAiB,QAAQ,OAAO,gBAAgB;AAAA,QACnG;AAEA,cAAM,UAAU,MAAM,cAAc,UAAU,KAAK,OAAO,OAAO;AACjE,YAAI,UAAU,aAAa;AACvB,gBAAM,IAAI,MAAM,2BAA2B,aAAa,UAAUA,QAAO,YAAY,SAAS,QAAQ,QAAQ,CAAC,UAAU,QAAQ,EAAE;AAAA,QACvI;AAEA,cAAM,YAAY,MAAM,cAAc,UAAU,KAAK,OAAO,SAAS,sBAAsB;AAC3F,YAAI,YAAY,aAAa;AACzB,UAAAD,QAAO,KAAK,aAAa,aAAa,wBAAwB;AAC9D,gBAAM,KAAK,MAAM,cAAc,QAAQ,wBAAwBC,QAAO,UAAU;AAChF,UAAAD,QAAO,KAAK,qBAAqB,GAAG,IAAI,EAAE;AAC1C,gBAAM,GAAG,KAAK;AACd,UAAAA,QAAO,KAAK,oBAAoB;AAAA,QACpC;AAEA,eAAO;AAAA,MACX,GAAG,GAAG,mCAAmC,aAAa,EAAE;AAAA,IAC5D,WAAW,kBAAkB,OAAO;AAChC,YAAM,KAAK,iBAAiB,OAAO,aAAa;AAC5C,cAAM,UAAU,MAAM,SAAS,WAAW,KAAK,OAAQ,OAAO;AAC9D,YAAI,UAAU,aAAa;AACvB,gBAAM,IAAI,MAAM,kCAAkCC,QAAO,YAAY,OAAO,CAAC,UAAU,QAAQ,EAAE;AAAA,QACrG;AACA,eAAO;AAAA,MACX,GAAG,GAAG,mBAAmB;AAAA,IAC7B;AAGA,IAAAD,QAAO,KAAK,mBAAmB,QAAQ,IAAI,aAAa,OAAO,cAAc,EAAE;AAE/E,WAAO,MAAM,KAAK,iBAAiB,OAAO,aAAa;AAEnD,WAAK,SAAS,IAAIC,QAAO,OAAO,KAAK,OAAQ,YAAY,QAAQ;AAEjE,YAAM,SAAS,IAAIA,QAAO,SAAS,wBAAwB;AAAA,QACvD;AAAA,MACJ,GAAG,KAAK,MAAM;AAEd,YAAM,SAAS;AAAA,QACX,SAAS,QAAQ;AAAA,QACjB,UAAU,SAAS;AAAA,QACnB,KAAK;AAAA;AAAA,QACL,WAAW,KAAK,OAAO;AAAA,QACvB,UAAU;AAAA,QACV,kBAAkB;AAAA;AAAA,QAClB,mBAAmB;AAAA,MACvB;AAEA,YAAM,YAAY,kBAAkB,QAAQ,EAAE,OAAO,YAAY,IAAI,CAAC;AAEtE,YAAM,KAAK,MAAM,OAAO,iBAAiB,QAAQ,SAAS;AAC1D,MAAAD,QAAO,KAAK,0BAA0B,GAAG,IAAI,EAAE;AAG/C,YAAM,UAAU,MAAM,GAAG,KAAK;AAC9B,MAAAA,QAAO,KAAK,2BAA2B,QAAQ,WAAW,EAAE;AAE5D,aAAO,GAAG;AAAA,IACd,GAAG,GAAG,sBAAsB,aAAa,OAAO,cAAc,EAAE;AAAA,EACpE;AACJ;AA9Sa,uBACF,cAAc;;;ADpBlB,IAAM,2BAAmC;AAAA,EAC5C,MAAM;AAAA,EACN,SAAS,CAAC,eAAe,QAAQ,SAAS,YAAY,cAAc;AAAA,EACpE,aAAa;AAAA,EACb,UAAU,OAAO,SAAwB,YAAoB;AACzD,WAAO,CAAC,CAAC,QAAQ,WAAW,iBAAiB,KAAK,CAAC,CAAC,QAAQ,WAAW,oBAAoB;AAAA,EAC/F;AAAA,EACA,SAAS,OACL,SACA,SACA,OACA,SACA,aACC;AACD,IAAAG,aAAY,KAAK,0CAA0C;AAE3D,UAAM,UAAU,QAAQ,QAAQ,QAAQ;AAGxC,UAAM,mBAAmB,CAAC,SAAiB;AAEvC,YAAM,aAAa,KAAK,YAAY,EAC/B,QAAQ,+CAA+C,EAAE,EACzD,QAAQ,2BAA2B,MAAM,EACzC,KAAK;AAGV,YAAM,cAAc,WAAW,MAAM,iBAAiB;AACtD,YAAM,SAAS,cAAc,YAAY,CAAC,IAAI;AAG9C,YAAM,oBAAoB,WAAW,QAAQ,QAAQ,EAAE,EAAE,KAAK;AAG9D,YAAM,QAAQ,kBAAkB,MAAM,MAAM;AAE5C,UAAI,UAAU;AACd,UAAI,WAAW;AAEf,UAAI,MAAM,UAAU,GAAG;AAEnB,cAAM,WAAW,MAAM,CAAC,EAAE,KAAK,EAAE,MAAM,KAAK;AAC5C,cAAM,UAAU,MAAM,CAAC,EAAE,KAAK,EAAE,MAAM,KAAK;AAE3C,kBAAU,SAAS,SAAS,SAAS,CAAC;AACtC,mBAAW,QAAQ,CAAC;AAAA,MACxB,OAAO;AAEH,cAAM,QAAQ,kBAAkB,MAAM,KAAK,EAAE,OAAO,OAAK,EAAE,SAAS,CAAC;AACrE,cAAM,SAAS,MAAM,OAAO,OAAK,iBAAiB,EAAE,YAAY,CAAC,CAAC;AAElE,YAAI,OAAO,UAAU,GAAG;AACpB,oBAAU,OAAO,CAAC;AAClB,qBAAW,OAAO,CAAC;AAAA,QACvB,WAAW,OAAO,WAAW,GAAG;AAE5B,oBAAU,OAAO,CAAC;AAClB,qBAAW;AAAA,QACf;AAAA,MACJ;AAEA,aAAO;AAAA,QACH,QAAQ,WAAW,MAAM;AAAA,QACzB,SAAS,QAAQ,YAAY;AAAA,QAC7B,UAAU,SAAS,YAAY;AAAA,MACnC;AAAA,IACJ;AAEA,UAAM,cAAc,iBAAiB,OAAO;AAE5C,IAAAA,aAAY,KAAK,wBAAwB,WAAW;AAGpD,QAAI,CAAC,YAAY,UAAU,MAAM,YAAY,MAAM,KAAK,YAAY,UAAU,GAAG;AAC7E,YAAM,WAAW;AACjB,UAAI,UAAU;AACV,iBAAS,EAAE,MAAM,SAAS,CAAC;AAAA,MAC/B;AACA,aAAO,EAAE,SAAS,OAAO,OAAO,iCAAiC;AAAA,IACrE;AAGA,QAAI,CAAC,YAAY,QAAS,aAAY,UAAU;AAChD,QAAI,CAAC,YAAY,SAAU,aAAY,WAAW;AAGlD,UAAM,gBAAgB,iBAAiB,YAAY,OAAO;AAC1D,UAAM,iBAAiB,iBAAiB,YAAY,QAAQ;AAE5D,QAAI,CAAC,eAAe;AAChB,YAAM,WAAW,SAAS,YAAY,OAAO;AAC7C,UAAI,UAAU;AACV,iBAAS,EAAE,MAAM,SAAS,CAAC;AAAA,MAC/B;AACA,aAAO,EAAE,SAAS,OAAO,OAAO,4BAA4B,YAAY,OAAO,GAAG;AAAA,IACtF;AAEA,QAAI,CAAC,gBAAgB;AACjB,YAAM,WAAW,SAAS,YAAY,QAAQ;AAC9C,UAAI,UAAU;AACV,iBAAS,EAAE,MAAM,SAAS,CAAC;AAAA,MAC/B;AACA,aAAO,EAAE,SAAS,OAAO,OAAO,6BAA6B,YAAY,QAAQ,GAAG;AAAA,IACxF;AAEA,QAAI;AACA,MAAAA,aAAY,KAAK,0CAA0C;AAC3D,YAAM,UAAU,IAAI,uBAAuB;AAC3C,YAAM,QAAQ,WAAW,OAAO;AAEhC,MAAAA,aAAY,KAAK,mBAAmB,YAAY,MAAM,IAAI,YAAY,OAAO,OAAO,YAAY,QAAQ,EAAE;AAG1G,UAAI,UAAU;AACV,iBAAS;AAAA,UACL,MAAM,6BAAsB,YAAY,MAAM,IAAI,YAAY,OAAO,WAAM,YAAY,QAAQ;AAAA;AAAA;AAAA,QACnG,CAAC;AAAA,MACL;AAEA,YAAM,SAAS,MAAM,QAAQ;AAAA,QACzB,YAAY;AAAA,QACZ,YAAY;AAAA,QACZ,YAAY,OAAO,SAAS;AAAA,MAChC;AAEA,YAAM,aAAa;AAAA;AAAA,YACI,YAAY,MAAM,IAAI,YAAY,OAAO,WAAM,YAAY,QAAQ;AAAA,yBACtD,MAAM;AAAA,uDACwB,MAAM;AAExE,UAAI,UAAU;AACV,iBAAS;AAAA,UACL,MAAM;AAAA,QACV,CAAC;AAAA,MACL;AAEA,aAAO;AAAA,QACH,SAAS;AAAA,QACT,MAAM,mCAAmC,MAAM;AAAA,QAC/C,MAAM;AAAA,UACF;AAAA,UACA,SAAS,YAAY;AAAA,UACrB,UAAU,YAAY;AAAA,UACtB,QAAQ,YAAY;AAAA,UACpB,aAAa,2BAA2B,MAAM;AAAA,QAClD;AAAA,MACJ;AAAA,IAEJ,SAAS,OAAY;AACjB,MAAAA,aAAY,MAAM,8CAA8C,KAAK;AAGrE,UAAI,eAAe;AAEnB,UAAI,MAAM,QAAQ,SAAS,oBAAoB,KAAK,MAAM,QAAQ,SAAS,cAAc,GAAG;AACxF,uBAAe,uBAAkB,YAAY,OAAO;AAAA,MACxD,WAAW,MAAM,QAAQ,SAAS,aAAa,KAAK,MAAM,QAAQ,SAAS,SAAS,GAAG;AACnF,uBAAe;AAAA,MACnB,WAAW,MAAM,QAAQ,SAAS,UAAU,KAAK,MAAM,QAAQ,SAAS,OAAO,GAAG;AAC9E,uBAAe;AAAA,MACnB,WAAW,MAAM,QAAQ,SAAS,WAAW,KAAK,MAAM,QAAQ,SAAS,SAAS,GAAG;AACjF,uBAAe;AAAA,MACnB,WAAW,MAAM,QAAQ,SAAS,gBAAgB,GAAG;AACjD,uBAAe;AAAA,MACnB,WAAW,MAAM,QAAQ,SAAS,WAAW,KAAK,MAAM,QAAQ,SAAS,UAAU,GAAG;AAClF,uBAAe;AAAA,MACnB,OAAO;AACH,uBAAe,uBAAkB,MAAM,OAAO;AAAA,MAClD;AAEA,UAAI,UAAU;AACV,iBAAS;AAAA,UACL,MAAM;AAAA,QACV,CAAC;AAAA,MACL;AAEA,aAAO,EAAE,SAAS,OAAO,OAAO,OAAO,WAAW,gBAAgB;AAAA,IACtE;AAAA,EACJ;AAAA,EACA,UAAU;AAAA,IACN;AAAA,MACI;AAAA,QACI,MAAM;AAAA,QACN,SAAS,EAAE,MAAM,uBAAuB;AAAA,MAC5C;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,UACN,QAAQ;AAAA,QACZ;AAAA,MACJ;AAAA,IACJ;AAAA,IACA;AAAA,MACI;AAAA,QACI,MAAM;AAAA,QACN,SAAS,EAAE,MAAM,yBAAyB;AAAA,MAC9C;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,UACN,QAAQ;AAAA,QACZ;AAAA,MACJ;AAAA,IACJ;AAAA,IACA;AAAA,MACI;AAAA,QACI,MAAM;AAAA,QACN,SAAS,EAAE,MAAM,0BAA0B;AAAA,MAC/C;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,UACN,QAAQ;AAAA,QACZ;AAAA,MACJ;AAAA,IACJ;AAAA,IACA;AAAA,MACI;AAAA,QACI,MAAM;AAAA,QACN,SAAS,EAAE,MAAM,0BAA0B;AAAA,MAC/C;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,UACN,QAAQ;AAAA,QACZ;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AACJ;;;AExOO,IAAM,gBAAwB;AAAA,EACjC,MAAM;AAAA,EACN,aAAa;AAAA,EACb,SAAS;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA;AAAA,EACJ;AAAA,EACA,YAAY,CAAC;AAAA,EACb,WAAW,CAAC;AAChB;AAEA,IAAO,gBAAQ;","names":["elizaLogger","elizaLogger","elizaLogger","Service","logger","ethers","QUOTER_ADDRESS","QUOTE_ABI","Service","logger","ethers","QUOTER_ADDRESS","elizaLogger"]}